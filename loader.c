#include <c64/keyboard.h>
#include <c64/memmap.h>
#include <c64/cia.h>
#include <c64/vic.h>
#include <c64/easyflash.h>
#include <c64/charwin.h>
#include <string.h>

// Main code & data region
#pragma section( mainCode, 0 )
#pragma section( mainData, 0 )

#include <engine/titleScreenIrq.h>
#include <engine/easyFlashBanks.h>
#include <assets/titleScreen.h>
#include <assets/mainGfx.h>
#include <assets/music.h>
#include <translation/textsPL.h>
#include <translation/textsEN.h>
#include "kielbasa.h"
#include "common.h"

// Shared code/data region, copied from easyflash bank 0 to ram during startup
/* #pragma region( main, 0x0900, 0x6000, , , { code, data, bss, heap, stack } ) */
/* #pragma region( main, 0x7000, 0x7fff, , , { code, data, bss, heap, stack } ) */
#pragma region( main, 0x7000, 0xbfff, , , { code, data, bss, heap, stack } )
#pragma region( mainCodeRegion1, 0x0900, 0x5fff, , MAIN_CODE_BANK_1, { mainCode, mainData, bss, heap, stack } )

// Switching code generation back to shared section
#pragma code ( code )
#pragma data ( data )

void gameStartup(){
    // obsolete, done in main()
    // Enable ROM
    /* mmap_set(MMAP_ROM); */

    // screen off
    vic.ctrl1 = VIC_CTRL1_BMM | VIC_CTRL1_RSEL | 3;

    // Init CIAs (no kernal rom was executed so far)
    cia_init();

    __asm {
        // same init stuff the kernel calls after reset
        // ldx #0
        // stx $d016
        jsr $ff84   // Initialise I/O

        // These may not be needed - depending on what you''ll do
        // jsr $ff87   // Initialise System Constants
        // jsr $ff8a   // Restore Kernal Vectors
        // jsr $ff81   // Initialize screen editor
    }
    
    // this goes directly from ROM - need to switch bank
    eflash.bank = TITLE_SCREEN_BANK;
    loadTitleScreen();

    // splash and turn screen on
    splashScreen(true, 3);

    // get the main sprites, fonts etc
    eflash.bank = MAIN_GFX_BANK;
    loadMainGfx();

    eflash.bank = MUSIC_BANK;
    loadMusic();

    __asm {
        sei
        lda #$7f
        sta $dc0d  //disable timer interrupts which can be generated by the two CIA chips
        sta $dd0d  //the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better
                   //stop it.

        lda $dc0d  //by reading this two registers we negate any pending CIA irqs.
        lda $dd0d  //if we don't do this, a pending CIA irq might occur after we finish setting up our irq.
                   //we don't want that to happen.
        
        // init music
        lda #MSX_ROM
        sta $01
        lda #$00
        jsr MSX_INIT
    }
    *(void **)0x0314 = titleScreenIrq1;     // Install interrupt routine
    vic.intr_enable = 1;             // Enable raster interrupt
    vic.ctrl1 &= 0x7f;               // Set raster line for IRQ
    vic.raster = 0;

    __asm {
        cli
    }

    eflash.bank = TRANSLATION_PL_BANK;
    loadTranslation();

    // ready steady GO
    do { keyb_poll(); } while (!keyb_key);
    keyb_key = 0;

    // splash and turn screen off
    splashScreen(false, 1);

    mainLoop();
}

int main(void) {        // _mainLoader() {}
    // [done] copy mainCode and mainData from CRT banks to RAM

    // [done] make sure crt is visible
    mmap_set(MMAP_ROM);

    // mount a bank
    eflash.bank = MAIN_CODE_BANK_1;

    // copy to RAM
    memcpy((char*)0x0900, (char*)0x8000, 0xbfff);

    // run main routine
    gameStartup();
}

#pragma code ( mainCode )
#pragma data ( mainData )

//-------------------------------------------------------------
// could do with a better home
//-------------------------------------------------------------
inline signed char babs(signed char val){
    if(val < 0){
        return -val;
    }
    return val;
}

void cwin_write_string_raw(CharWin * win, const char * buffer)
{
	char * dp = win->sp;
	for(char y=0; y<win->wy; y++)
	{
		for(char x=0; x<win->wx; x++)
		{
			char ch = *buffer;
			if (ch)
			{
				dp[x] = ch;
				buffer++;
			}
			else
				dp[x] = ' ';
		}
		dp += 40;
	}	

}






